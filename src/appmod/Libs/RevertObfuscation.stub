<?php
/**
 * @see       https://github.com/rpdesignerfly/artisan-obfuscator
 * @copyright Copyright (c) 2018 Ricardo Pereira Dias (https://rpdesignerfly.github.io)
 * @license   https://github.com/rpdesignerfly/artisan-obfuscator/blob/master/license.md
 */

declare(strict_types=1);

//
// Funções falsas apenas para dificultar
//
function cfForgetShow($data, $revert = false)
{
    return baseOne($data, $revert);
}

function cryptOf($data, $revert = false)
{
    return baseTwo($data, $revert);
}

function unsetZeros($data, $revert = false)
{
    return baseOne($data, $revert);
}

function deflatingNow($data, $revert = false)
{
    return baseTwo($data, $revert);
}

function zeroizeCipher($data, $revert = false)
{
    return baseThree($data, $revert);
}

function iqutZ($data, $revert = false)
{
    return baseTwo($data, $revert);
}

function sagaPlus($data, $revert = false)
{
    return baseThree($data, $revert);
}

//
// Funções com variações para descaracterização
// do código compactado.
//
// O código é compactado em base64 e o resultado
// é quebrado em duas partes. Entre as duas
// partes é inserida uma string não-base64.
// Ao tentar reverter o base64, o código ficará quebrado.
//
function baseOne($data, $revert = false)
{
    if ($revert == false) {

        $encoded = base64_encode($data);

        // Separa em dois pedaços
        $partOne = mb_substr($encoded, 0, 10, "utf-8");
        $partTwo = mb_substr($encoded, 10, NULL, "utf-8");

        // Insere 'Sg' para invalidar o base64
        return $partOne . 'Sg' . $partTwo;

    } else {

        // Separa em dois pedaços
        $partOne = mb_substr($data, 0, 10, "utf-8");
        $partTwo = mb_substr($data, 12, NULL, "utf-8");

        // Remove 'Sg' para validar o base64
        return base64_decode($partOne . $partTwo);
    }
}

function baseTwo($data, $revert = false)
{
    if ($revert == false) {

        $encoded = base64_encode($data);

        // Separa em dois pedaços
        $partOne = mb_substr($encoded, 0, 5, "utf-8");
        $partTwo = mb_substr($encoded, 5, NULL, "utf-8");

        // Insere 'Sg' para invalidar o base64
        return $partOne . 'Sg' . $partTwo;

    } else {

        // Separa em dois pedaços
        $partOne = mb_substr($data, 0, 5, "utf-8");
        $partTwo = mb_substr($data, 7, NULL, "utf-8");

        // Remove 'Sg' para validar o base64
        return base64_decode($partOne . $partTwo);
    }
}

function baseThree($data, $revert = false)
{
    if ($revert == false) {

        $encoded = base64_encode($data);

        // Separa em dois pedaços
        $partOne = mb_substr($encoded, 0, 15, "utf-8");
        $partTwo = mb_substr($encoded, 15, NULL, "utf-8");

        // Insere 'Sg' para invalidar o base64
        return $partOne . 'Sg' . $partTwo;

    } else {

        // Separa em dois pedaços
        $partOne = mb_substr($data, 0, 15, "utf-8");
        $partTwo = mb_substr($data, 17, NULL, "utf-8");

        // Remove 'Sg' para validar o base64
        return base64_decode($partOne . $partTwo);
    }
}

//
// Funções falsas para devolução de chaves booleanas
//
function decompressMD5(){ return true; }
function unsetLogger(){ return true; }
function loopNested(){ return true; }
function vorticeData(){ return true; }
function cipherBinary(){ return true; }
